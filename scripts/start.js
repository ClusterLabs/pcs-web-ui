/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable import/no-extraneous-dependencies */

// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = "development";
process.env.NODE_ENV = "development";

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on("unhandledRejection", err => {
  throw err;
});

// Ensure environment variables are read.
require("../config/env");

const fs = require("fs");
const path = require("path");

const webpack = require("webpack");
const WebpackDevServer = require("webpack-dev-server");
const {
  createCompiler,
  prepareUrls,
} = require("react-dev-utils/WebpackDevServerUtils");

const paths = require("../config/paths");
const webpackConfig = require("../config/webpack.config");
const createDevServerConfig = require("../config/webpackDevServer.config");

// Tools like Cloud9 rely on this.
const port = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || "0.0.0.0";

if (process.env.HOST) {
  console.log(`Attempting to bind to env.HOST: ${process.env.HOST}`);
}

// webpack needs to know it to put the right <script> hrefs into HTML even in
// single-page apps that may serve index.html for nested URLs like /todos/42.
// We can't use a relative path in HTML because we don't want to load something
// like /todos/42/static/js/bundle.7289d.js. We have to know the root.
const publicPath = "/";

const protocol = process.env.HTTPS === "true" ? "https" : "http";
const appName = require(paths.appPackageJson).name;

const urls = prepareUrls(protocol, HOST, port, publicPath.slice(0, -1));
// Create a webpack compiler that is configured with custom messages.
const compiler = createCompiler({
  appName,
  config: webpackConfig({publicPath}),
  urls,
  useTypeScript: true,
  webpack,
});

const sockPath = process.env.WDS_SOCKET_PATH || "/ws";
const proxy = process.env.PCSD_DEV_BACKEND || "http://localhost:5000";
console.log(`Backend requests go to ${proxy}`);
const proxyConfig = [
  {
    target: proxy,
    logLevel: "silent",
    context: (pathname, /*req*/ {method, headers}) => {
      // We use a heuristic:
      // 1. We want to proxy all the requests that are not meant for static
      // assets and as all the requests for static assets will be using GET
      // method, we can proxy all non-GET requests.
      const isStaticAsset = fs.existsSync(
        path.resolve(
          paths.appPublic,
          pathname.replace(new RegExp(`^${publicPath}`), ""),
        ),
      );
      // 2. For GET requests, if request accepts text/html, we pick /index.html.
      // Modern browsers include text/html into accept header when navigating.
      // However API calls like fetch() wonâ€™t generally accept text/html.
      const isNavigation = headers.accept?.indexOf("text/html") !== -1 ?? false;
      const isSocket = pathname.startsWith(sockPath);

      return method !== "GET" || !(isSocket || isStaticAsset || isNavigation);
    },
    onProxyReq: proxyReq => {
      // Browsers may send Origin headers even with same-origin
      // requests. To prevent CORS issues, we have to change
      // the Origin to match the target URL.
      if (proxyReq.getHeader("origin")) {
        proxyReq.setHeader("origin", proxy);
      }
    },
    onError: (/*err*/ {code}, /*req*/ {headers, url}, res) => {
      const host = headers && headers.host;
      const msg = `Couldn't proxy request ${url} from ${host} to ${proxy} (${code})`;
      console.log(msg);
      console.log(
        "See https://nodejs.org/api/errors.html#errors_common_system_errors\n",
      );

      // And immediately send the proper error response to the client.
      // Otherwise, the request will eventually timeout with ERR_EMPTY_RESPONSE
      // on the client side.
      if (res.writeHead && !res.headersSent) {
        res.writeHead(500);
      }
      res.end(msg);
    },
    secure: false,
    changeOrigin: true,
    ws: true,
    xfwd: true,
  },
];
// Serve webpack assets generated by the compiler over a web server.
const devServer = new WebpackDevServer(
  {
    ...createDevServerConfig(proxyConfig, urls.lanUrlForConfig, publicPath),
    host: HOST,
    port,
  },
  compiler,
);
devServer.start();

["SIGINT", "SIGTERM"].forEach(function (sig) {
  process.on(sig, function () {
    devServer.close();
    process.exit();
  });
});
